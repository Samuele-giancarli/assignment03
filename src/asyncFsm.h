#ifndef __ASYNCFSM__
#define __ASYNCFSM__

#define MAX_EVQUEUE_SIZE 20
#define NUM_PINS 13


/*Rappresenta il concetto di evento. Ogni evento ha un tipo, che indica
ci√≤ che deve succedere*/
class Event {
    public:
        Event(int Type);
        int getType();
    private:
    int type;
};

/*Rapppresenta l'observer, con cui i vari elementi si interfacciano. Esso
una volta richiamato notifica EventSource della creazione di un nuovo evento*/
class Observer {
    public:
        virtual void notifyEvent(Event* ev);
};

/* Si occupa di creare eventi e di bindare un interrupt ad un pin in particolare*/
class EventSource {
    public:
        void registerObserver(Observer* observer);

        virtual void notifyInterrupt(int pin) = 0;

    protected:
        void bindInterrupt(int pin);
        void generateEvent(Event* ev);
        Observer* observer;
};

class InterruptDispatcher {
    public:
        InterruptDispatcher();
        void bind(int pin, EventSource* src);
        void notifyInterrupt(int pin);
    private:
        EventSource* sourceRegisteredOnPin[NUM_PINS];
        void (*notifyFunctions[NUM_PINS])() = {};

    static void notifyInterrupt_0();
    static void notifyInterrupt_1();
    static void notifyInterrupt_2();
    static void notifyInterrupt_3();
    static void notifyInterrupt_4();
    static void notifyInterrupt_5();
    static void notifyInterrupt_6();
    static void notifyInterrupt_7();
    static void notifyInterrupt_8();
    static void notifyInterrupt_9();
    static void notifyInterrupt_10();
    static void notifyInterrupt_11();
    static void notifyInterrupt_12();
    static void notifyInterrupt_13();
};

/**
 * Class representing an event queue, used inside the async FSM
 */
class EventQueue {      
public:
  EventQueue();
  bool isEmpty();
  void enqueue(Event* ev);
  Event* dequeue();  
private:
  Event* queue[MAX_EVQUEUE_SIZE];
  int head, tail; 
};

/**
 * Base abstract class for implementing asynchronous
 * Finite State Machines.
 * 
 * NOTES:
 * - it is an Observer of events generated by event source
 * - the state is meant to be modelled by derived classes
 */
class AsyncFSM : public Observer {
public:
  virtual void handleEvent(Event* ev) = 0;
  void notifyEvent(Event* ev);  
  void checkEvents();  

protected:
  AsyncFSM();    
  EventQueue eventQueue;
};

#endif
